<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NKP Quick Deploy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .card { background: white; border: 1px solid rgb(226 232 240); border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 10px 30px -12px rgba(15, 23, 42, 0.25); }
      .label { display: block; color: rgb(71 85 105); font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem; }
      .input { width: 100%; border-radius: 0.6rem; border: 1px solid rgb(226 232 240); padding: 0.6rem 0.75rem; color: rgb(15 23 42); outline: none; transition: all 0.15s ease; }
      .input:focus { border-color: rgb(59 130 246); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
    </style>
  </head>
  <body class="bg-slate-50 min-h-screen text-slate-900">
    <div class="max-w-6xl mx-auto py-10 px-4 space-y-6">
      <header class="flex items-center justify-between">
        <div>
          <p class="text-sm uppercase tracking-wide text-blue-600 font-semibold">Nutanix Kubernetes Platform</p>
          <h1 class="text-3xl font-bold text-slate-900">Guided Deployment</h1>
          <p class="text-slate-600">Reference implementation inspired by nkp-quickstart with a single-threaded, scripted workflow.</p>
        </div>
        <div class="flex items-center space-x-3">
          <button id="downloadBtn" class="px-4 py-2 rounded-lg bg-white border border-slate-200 shadow-sm hover:border-blue-500">Download Config</button>
          <label class="px-4 py-2 rounded-lg bg-white border border-slate-200 shadow-sm cursor-pointer hover:border-blue-500">
            <input type="file" id="uploadInput" class="hidden" />
            Upload Config
          </label>
        </div>
      </header>

      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <section class="card lg:col-span-2">
          <h2 class="text-xl font-semibold mb-4">Prism Central Connection</h2>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="label" for="pc_ip">Prism Central IP</label>
              <input id="pc_ip" class="input" placeholder="10.10.10.10" />
            </div>
            <div>
              <label class="label" for="pc_user">Username</label>
              <input id="pc_user" class="input" placeholder="admin" />
            </div>
            <div>
              <label class="label" for="pc_password">Password</label>
              <input id="pc_password" type="password" class="input" placeholder="••••••" />
            </div>
            <div class="flex items-center space-x-2 pt-6">
              <input id="verify_ssl" type="checkbox" class="h-4 w-4 text-blue-600" />
              <label for="verify_ssl" class="text-sm text-slate-700">Verify TLS certificates</label>
            </div>
          </div>
          <div class="mt-4 flex items-center space-x-3">
            <button id="verifyBtn" class="px-5 py-2 rounded-lg bg-blue-600 text-white font-semibold shadow hover:bg-blue-700">Verify & Fetch</button>
            <p id="verifyStatus" class="text-sm text-slate-600"></p>
          </div>
        </section>

        <section class="card">
          <h2 class="text-xl font-semibold mb-4">Progress</h2>
          <div class="w-full bg-slate-200 rounded-full h-3 mb-3">
            <div id="progressBar" class="bg-blue-600 h-3 rounded-full" style="width: 0%;"></div>
          </div>
          <p id="progressText" class="text-sm text-slate-600">Idle</p>
          <div class="mt-4 h-40 overflow-y-auto bg-slate-900 text-slate-50 text-sm font-mono rounded-lg p-3" id="logBox"></div>
        </section>
      </div>

      <section class="card">
        <h2 class="text-xl font-semibold mb-4">Deployment Inputs</h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label class="label" for="cluster">Cluster</label>
            <select id="cluster" class="input"></select>
          </div>
          <div>
            <label class="label" for="subnet">Subnet</label>
            <select id="subnet" class="input"></select>
          </div>
          <div>
            <label class="label" for="project">Project</label>
            <select id="project" class="input"></select>
          </div>
          <div>
            <label class="label" for="container">Storage Container</label>
            <select id="container" class="input"></select>
          </div>
          <div>
            <label class="label" for="nodeCidr">Node CIDR</label>
            <input id="nodeCidr" class="input" />
          </div>
          <div>
            <label class="label" for="serviceCidr">Service CIDR</label>
            <input id="serviceCidr" class="input" />
          </div>
          <div>
            <label class="label" for="metallb">MetalLB IP Range</label>
            <input id="metallb" class="input" />
          </div>
          <div>
            <label class="label" for="sshUser">SSH Username</label>
            <input id="sshUser" class="input" />
          </div>
          <div>
            <label class="label" for="sshKey">SSH Private Key Path</label>
            <input id="sshKey" class="input" />
          </div>
        </div>
        <div class="mt-6 flex items-center space-x-3">
          <button id="saveBtn" class="px-4 py-2 rounded-lg bg-white border border-slate-200 shadow-sm hover:border-blue-500">Save Config</button>
          <button id="runBtn" class="px-5 py-2 rounded-lg bg-emerald-600 text-white font-semibold shadow hover:bg-emerald-700">Launch Scripted Install</button>
        </div>
      </section>
    </div>

    <script>
      const initialConfig = {{ config|tojson }};

      const fields = {
        pc_ip: document.getElementById('pc_ip'),
        pc_user: document.getElementById('pc_user'),
        pc_password: document.getElementById('pc_password'),
        verify_ssl: document.getElementById('verify_ssl'),
        cluster: document.getElementById('cluster'),
        subnet: document.getElementById('subnet'),
        project: document.getElementById('project'),
        container: document.getElementById('container'),
        nodeCidr: document.getElementById('nodeCidr'),
        serviceCidr: document.getElementById('serviceCidr'),
        metallb: document.getElementById('metallb'),
        sshUser: document.getElementById('sshUser'),
        sshKey: document.getElementById('sshKey'),
      };

      function seedForm(cfg) {
        fields.pc_ip.value = cfg.PRISM_CENTRAL_IP || '';
        fields.pc_user.value = cfg.PRISM_CENTRAL_USERNAME || '';
        fields.pc_password.value = cfg.PRISM_CENTRAL_PASSWORD || '';
        fields.verify_ssl.checked = cfg.PRISM_CENTRAL_VERIFY_SSL || false;
        fields.nodeCidr.value = cfg.NODE_CIDR || '';
        fields.serviceCidr.value = cfg.SERVICE_CIDR || '';
        fields.metallb.value = cfg.METALLB_IP_RANGE || '';
        fields.sshUser.value = cfg.SSH_USERNAME || '';
        fields.sshKey.value = cfg.SSH_PRIVATE_KEY_PATH || '';
        populateSelect(fields.cluster, cfg.clusters || [], cfg.TARGET_CLUSTER);
        populateSelect(fields.subnet, cfg.subnets || [], cfg.TARGET_SUBNET);
        populateSelect(fields.project, cfg.projects || [], cfg.TARGET_PROJECT);
        populateSelect(fields.container, cfg.storage_containers || [], cfg.STORAGE_CONTAINER);
      }

      function populateSelect(element, items, selected) {
        element.innerHTML = '';
        const options = items.length ? items : [{ name: 'Select after verify', uuid: '' }];
        options.forEach((item) => {
          const opt = document.createElement('option');
          opt.value = item.uuid || item.name || '';
          opt.textContent = item.name || item.uuid;
          if (selected && selected === opt.value) opt.selected = true;
          element.appendChild(opt);
        });
      }

      seedForm(initialConfig);

      document.getElementById('verifyBtn').addEventListener('click', async () => {
        const payload = {
          pc_ip: fields.pc_ip.value,
          username: fields.pc_user.value,
          password: fields.pc_password.value,
          verify_ssl: fields.verify_ssl.checked,
        };
        document.getElementById('verifyStatus').textContent = 'Contacting Prism Central...';
        const res = await fetch('/api/verify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json();
        if (data.success) {
          document.getElementById('verifyStatus').textContent = 'Connected. Values populated below.';
          const inventory = data.inventory;
          populateSelect(fields.cluster, inventory.clusters, initialConfig.TARGET_CLUSTER);
          populateSelect(fields.subnet, inventory.subnets, initialConfig.TARGET_SUBNET);
          populateSelect(fields.project, inventory.projects, initialConfig.TARGET_PROJECT);
          populateSelect(fields.container, inventory.storage_containers, initialConfig.STORAGE_CONTAINER);
          initialConfig.clusters = inventory.clusters;
          initialConfig.subnets = inventory.subnets;
          initialConfig.projects = inventory.projects;
          initialConfig.storage_containers = inventory.storage_containers;
        } else {
          document.getElementById('verifyStatus').textContent = data.error || 'Unable to connect';
        }
      });

      document.getElementById('saveBtn').addEventListener('click', async () => {
        const payload = collectPayload();
        await fetch('/api/save-config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        document.getElementById('verifyStatus').textContent = 'Configuration saved locally.';
      });

      document.getElementById('runBtn').addEventListener('click', async () => {
        const payload = collectPayload();
        const res = await fetch('/api/run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json();
        if (!data.success) alert(data.error || 'Unable to start deployment');
      });

      document.getElementById('downloadBtn').addEventListener('click', () => {
        window.location.href = '/api/download-config';
      });

            function applyProgress(progress) {
                if (!progress || typeof progress.percent === 'undefined') return;

                progressBar.style.width = `${progress.percent}%`;
                progressBar.dataset.status = progress.status || 'running';

                if (progress.step) {
                    statusText.textContent = progress.step;
                }

                if (progress.status === 'complete' || progress.status === 'error') {
                    document.querySelectorAll('.phase-card.active').forEach(card => stopPhaseTimer(card.dataset.label));
                    stopTotalTimer();
                } else if (progress.status === 'running' && !totalTimerStart) {
                    startTotalTimer();
                }

                if (progress.status === 'complete') {
                    document.querySelectorAll('.phase-card').forEach(card => card.classList.add('done'));
                    document.getElementById('launch').disabled = false;
                    statusText.textContent = progress.step || 'Complete';
                    updateTimers();
                }

                if (progress.status === 'error') {
                    document.getElementById('launch').disabled = false;
                    statusText.textContent = progress.step || 'Failed';
                    updateTimers();
                }
            }

            function launchDeployment() {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const phases = getSelectedPhases(mode);
                progressBar.style.width = '0%';
                progressBar.dataset.status = 'running';
                document.getElementById('launch').disabled = true;
                resetPhases(mode);
                resetTimers();
                statusText.textContent = 'Starting...';
                fetch('/api/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({mode, phases})
                }).then(async r => {
                    const data = await r.json();
                    if (!r.ok) {
                        appendTerminalLine(data.message || 'Unable to start deployment');
                        document.getElementById('launch').disabled = false;
                        statusText.textContent = 'Idle';
                        return;
                    }
                    appendTerminalLine(data.message || 'Deployment started');
                    statusText.textContent = `Running (${mode})`;
                    startTotalTimer();
                }).catch(err => {
                    appendTerminalLine(err.toString());
                    statusText.textContent = 'Idle';
                    resetTimers();
                });
            }

            function connectStream() {
                setConnectionState('open');
                const source = new EventSource('/api/stream');
        source.onopen = () => setConnectionState('open');
        source.onerror = () => setConnectionState('closed');
                source.onmessage = (event) => {
                    if (!event.data || event.data === '{}') return;
                    const payload = JSON.parse(event.data);
            if (payload.type === 'log') {
                appendTerminalLine(payload.message);
            }
            if (payload.type === 'status') {
                appendTerminalLine(payload.message);
                statusText.textContent = payload.message;
            }
            if (payload.type === 'phase') {
                updatePhaseStatus(payload.message, 'Running');
            }
                    if (payload.type === 'progress') {
                        try {
                            const progress = JSON.parse(payload.message);
                            applyProgress(progress);
                        } catch (e) {
                            console.warn('Progress parse error', e);
                        }
            }
        };
      }

            function hydrateStatus() {
                fetch('/api/status').then(async (r) => {
                    const data = await r.json();
                    const progress = data.state || {};
                    applyProgress({
                        percent: progress.progress ?? progress.percent ?? 0,
                        status: progress.status,
                        step: progress.step
                    });
                    if (!data.active) {
                        stopTotalTimer();
                    }
                }).catch(() => {
                    // no-op hydration failure
                });
            }

    document.getElementById('save-config').addEventListener('click', saveConfiguration);
            document.getElementById('launch').addEventListener('click', launchDeployment);
            document.getElementById('clear-terminal').addEventListener('click', () => terminalOutput.textContent = '');
            modeInputs.forEach(input => input.addEventListener('change', (e) => renderPhases(e.target.value)));

            renderPhases('automated');
            connectStream();
            hydrateStatus();
            updateTimers();
        </script>
</body>
</html>
