<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>NKP Bastion Deployment Dashboard</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<div class="page">
    <header class="hero">
        <div class="hero-copy">
            <p class="eyebrow">Bastion-host UI</p>
            <h1>NKP Deployment Control</h1>
            <p class="subtitle">Review the automated and phased workflows, capture deployment variables, and watch real-time progress without leaving your browser.</p>
            <div class="mode-toggle">
                <label>
                    <input type="radio" name="mode" value="automated" checked>
                    Automated (Parallel deploy + verify)
                </label>
                <label>
                    <input type="radio" name="mode" value="phased">
                    Phased (run steps individually)
                </label>
            </div>
            <div class="inline-status">
                <span class="dot green" id="connection-dot"></span>
                <span id="connection-label">Live event stream</span>
                <span class="divider">â€¢</span>
                <span class="status-pill" id="status-text">Idle</span>
            </div>
        </div>
        <div class="actions">
            <button id="save-config" class="btn ghost">ðŸ’¾ Save configuration</button>
            <button id="launch" class="btn primary">ðŸš€ Launch deployment</button>
        </div>
    </header>

    <main class="grid">
        <section class="card form-card">
            <div class="card-header">
                <div>
                    <p class="eyebrow">Configuration</p>
                    <h2>Deployment variables</h2>
                    <p class="muted">All scripts draw from this form. Fields marked with <span class="required">*</span> are required.</p>
                </div>
                <div class="header-actions">
                    <span class="badge">Hover tooltips explain every field</span>
                    <span id="save-status" class="muted"></span>
                </div>
            </div>
            <form id="config-form">
                <div class="section-list">
                    {% for section in field_sections %}
                        <div class="section">
                            <div class="section-header">
                                <div>
                                    <p class="eyebrow">{{ section.title }}</p>
                                    <p class="muted">{{ section.description }}</p>
                                </div>
                                <span class="pill">{{ section.id }}</span>
                            </div>
                            <div class="field-grid">
                                {% for key in section.fields %}
                                    {% set meta = field_metadata.get(key, {}) %}
                                    <div class="field">
                                        <label>
                                            {{ meta.label or key }}
                                            {% if meta.tooltip %}<span class="tooltip" title="{{ meta.tooltip }}">?</span>{% endif %}
                                            {% if meta.required %}<span class="required">*</span>{% endif %}
                                        </label>
                                        {% if meta.options %}
                                            <select name="{{ key }}">
                                                {% for option in meta.options %}
                                                    <option value="{{ option.value }}" {% if config.get(key, '') == option.value %}selected{% endif %}>{{ option.label }}</option>
                                                {% endfor %}
                                            </select>
                                        {% else %}
                                            <input
                                                type="{{ meta.input_type or 'text' }}"
                                                name="{{ key }}"
                                                value="{{ config.get(key, '') }}"
                                                placeholder="{{ meta.placeholder or '' }}"
                                            >
                                        {% endif %}
                                    </div>
                                {% endfor %}
                            </div>
                        </div>
                    {% endfor %}
                </div>
            </form>
        </section>

        <section class="card dashboard">
            <div class="card-header space-between">
                <div>
                    <p class="eyebrow">Progress</p>
                    <h2>Deployment status</h2>
                </div>
                <div class="timing-shell">
                    <div class="progress-shell">
                        <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="timer-block">
                        <div class="timer-label">Total time</div>
                        <div class="timer-value" id="total-timer">--:--</div>
                    </div>
                </div>
            </div>
            <div class="phase-controls" id="phase-toggle"></div>
            <div class="phase-list" id="phase-list"></div>
            <div class="terminal">
                <div class="terminal-header">
                    <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
                    <span class="terminal-title">Console output</span>
                    <div class="terminal-actions">
                        <button class="pill" id="clear-terminal" type="button">Clear</button>
                    </div>
                </div>
                <pre id="terminal-output"></pre>
            </div>
        </section>
    </main>
</div>

<script>
    const phaseSets = {{ phase_sets | tojson }};
            const terminalOutput = document.getElementById('terminal-output');
            const progressBar = document.getElementById('progress-bar');
            const phaseList = document.getElementById('phase-list');
            const modeInputs = document.querySelectorAll('input[name="mode"]');
            const saveStatus = document.getElementById('save-status');
            const statusText = document.getElementById('status-text');
            const connectionDot = document.getElementById('connection-dot');
            const totalTimerEl = document.getElementById('total-timer');
            let cachedPrismPassword = '';

            let phaseTimers = {};
            let totalTimerStart = null;
            let totalTimerStop = null;
            let timerInterval = null;

            function formatDuration(ms) {
                if (!ms || ms < 0) return '--:--';
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                if (hours > 0) {
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            function ensureTimerInterval() {
                if (!timerInterval) {
                    timerInterval = setInterval(updateTimers, 1000);
                }
            }

            function updateTimers() {
                if (totalTimerEl) {
                    if (totalTimerStart) {
                        const totalEnd = totalTimerStop || Date.now();
                        totalTimerEl.textContent = formatDuration(totalEnd - totalTimerStart);
                    } else {
                        totalTimerEl.textContent = '--:--';
                    }
                }

                document.querySelectorAll('.phase-card').forEach(card => {
                    const label = card.dataset.label;
                    const timerEl = card.querySelector('.phase-timer');
                    const timerData = phaseTimers[label];
                    if (!timerEl) return;
                    if (timerData && timerData.start) {
                        const endTime = timerData.end || Date.now();
                        timerEl.textContent = formatDuration(endTime - timerData.start);
                    } else {
                        timerEl.textContent = '--:--';
                    }
                });
            }

            function resetTimers() {
                phaseTimers = {};
                totalTimerStart = null;
                totalTimerStop = null;
                updateTimers();
            }

            function startTotalTimer() {
                totalTimerStart = Date.now();
                totalTimerStop = null;
                ensureTimerInterval();
                updateTimers();
            }

            function stopTotalTimer() {
                if (totalTimerStart && !totalTimerStop) {
                    totalTimerStop = Date.now();
                    updateTimers();
                }
            }

            function startPhaseTimer(label) {
                phaseTimers[label] = {start: Date.now(), end: null};
                ensureTimerInterval();
                updateTimers();
            }

            function stopPhaseTimer(label) {
                if (phaseTimers[label] && !phaseTimers[label].end) {
                    phaseTimers[label].end = Date.now();
                    updateTimers();
                }
            }

            function renderPhases(mode) {
                phaseList.innerHTML = '';
                const phases = phaseSets[mode] || [];
                phases.forEach(phase => {
                    const card = document.createElement('div');
                    card.className = 'phase-card pending';
                    card.dataset.label = phase;
                    card.innerHTML = `<div class="phase-title">${phase}</div><div class="phase-meta"><div class="phase-status">Pending</div><div class="phase-timer">--:--</div></div>`;
                    if (mode === 'phased') {
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = true;
                        checkbox.dataset.phase = phase;
                checkbox.className = 'phase-checkbox';
                card.prepend(checkbox);
            }
            phaseList.appendChild(card);
        });
    }

            function updatePhaseStatus(label, status) {
                const card = Array.from(document.querySelectorAll('.phase-card')).find(c => c.dataset.label === label);
                if (!card) return;

                document.querySelectorAll('.phase-card.active').forEach(activeCard => {
                    if (activeCard.dataset.label !== label) {
                        activeCard.classList.remove('active');
                        activeCard.classList.add('done');
                        const previousStatus = activeCard.querySelector('.phase-status');
                        previousStatus.textContent = 'Done';
                        stopPhaseTimer(activeCard.dataset.label);
                    }
                });

                const statusEl = card.querySelector('.phase-status');
                statusEl.textContent = status;
                card.classList.remove('pending', 'done');
                if (status === 'Running') {
                    card.classList.add('active');
                    startPhaseTimer(label);
                } else if (status === 'Done') {
                    card.classList.add('done');
                    stopPhaseTimer(label);
                } else {
                    card.classList.add('pending');
                }
            }

            function resetPhases(mode) {
                const phases = phaseSets[mode] || [];
                phaseTimers = {};
                phaseList.querySelectorAll('.phase-card').forEach(card => {
                    card.classList.remove('active', 'done');
                    card.classList.add('pending');
                    const statusEl = card.querySelector('.phase-status');
                    statusEl.textContent = 'Pending';
                    const timerEl = card.querySelector('.phase-timer');
                    if (timerEl) timerEl.textContent = '--:--';
                    if (mode === 'phased') {
                        const checkbox = card.querySelector('input[type="checkbox"]');
                        if (checkbox) checkbox.checked = phases.includes(card.dataset.label);
                    }
                });
                updateTimers();
            }

    function appendTerminalLine(text) {
        terminalOutput.textContent += `\n${text}`;
        terminalOutput.scrollTop = terminalOutput.scrollHeight;
    }

    function highlightMissing(fields) {
        document.querySelectorAll('#config-form input, #config-form select').forEach(el => el.classList.remove('invalid'));
        fields.forEach(field => {
            const el = document.querySelector(`[name="${field}"]`);
            if (el) el.classList.add('invalid');
        });
    }

    function setConnectionState(state) {
        if (state === 'open') {
            connectionDot.className = 'dot green';
            document.getElementById('connection-label').textContent = 'Live event stream';
        } else {
            connectionDot.className = 'dot red';
            document.getElementById('connection-label').textContent = 'Disconnected (retrying...)';
        }
    }

    function getRuntimePrismPassword() {
        const field = document.querySelector('input[name="PRISM_CENTRAL_PASSWORD"]');
        let value = field ? field.value : '';
        if (!value) {
            value = cachedPrismPassword;
        }
        if (!value) {
            value = window.prompt('Enter the Prism Central password (will not be saved to disk)');
            if (value === null) {
                return null;
            }
        }
        cachedPrismPassword = value;
        return value;
    }

    function saveConfiguration() {
        const formData = new FormData(document.getElementById('config-form'));
        const payload = Object.fromEntries(formData.entries());
        cachedPrismPassword = payload.PRISM_CENTRAL_PASSWORD || cachedPrismPassword;
        delete payload.PRISM_CENTRAL_PASSWORD;
        saveStatus.textContent = 'Saving...';
        fetch('/api/config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        }).then(async (r) => {
            const data = await r.json();
            if (!r.ok) {
                saveStatus.textContent = data.message || 'Validation failed';
                highlightMissing(data.missing || []);
                appendTerminalLine(data.message || 'Validation failed');
                return;
            }
            const suffix = cachedPrismPassword ? ' (Prism Central password kept in memory only)' : '';
            saveStatus.textContent = (data.message || 'Configuration saved') + suffix;
            highlightMissing([]);
            appendTerminalLine(data.message || 'Configuration saved');
        }).catch(err => {
            saveStatus.textContent = 'Save failed';
            appendTerminalLine(err.toString());
        });
    }

    function getSelectedPhases(mode) {
        if (mode !== 'phased') return phaseSets[mode];
        const boxes = document.querySelectorAll('.phase-checkbox');
        return Array.from(boxes).filter(b => b.checked).map(b => b.dataset.phase);
    }

            function launchDeployment() {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const phases = getSelectedPhases(mode);
                const prismPassword = getRuntimePrismPassword();
                if (prismPassword === null || prismPassword === '') {
                    appendTerminalLine('Launch cancelled: Prism Central password is required at runtime.');
                    statusText.textContent = 'Idle';
                    return;
                }
                progressBar.style.width = '0%';
                progressBar.dataset.status = 'running';
                document.getElementById('launch').disabled = true;
                resetPhases(mode);
                resetTimers();
                statusText.textContent = 'Starting...';
                fetch('/api/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({mode, phases, prismCentralPassword: prismPassword})
                }).then(async r => {
                    const data = await r.json();
                    if (!r.ok) {
                        appendTerminalLine(data.message || 'Unable to start deployment');
                        document.getElementById('launch').disabled = false;
                        statusText.textContent = 'Idle';
                        return;
                    }
                    appendTerminalLine(data.message || 'Deployment started');
                    statusText.textContent = `Running (${mode})`;
                    startTotalTimer();
                }).catch(err => {
                    appendTerminalLine(err.toString());
                    statusText.textContent = 'Idle';
                    resetTimers();
                });
            }

            function connectStream() {
                setConnectionState('open');
                const source = new EventSource('/stream');
        source.onopen = () => setConnectionState('open');
        source.onerror = () => setConnectionState('closed');
                source.onmessage = (event) => {
                    if (!event.data || event.data === '{}') return;
                    const payload = JSON.parse(event.data);
            if (payload.type === 'log') {
                appendTerminalLine(payload.message);
            }
            if (payload.type === 'status') {
                appendTerminalLine(payload.message);
                statusText.textContent = payload.message;
            }
            if (payload.type === 'phase') {
                updatePhaseStatus(payload.message, 'Running');
            }
                    if (payload.type === 'progress') {
                        try {
                            const progress = JSON.parse(payload.message);
                            progressBar.style.width = `${progress.percent}%`;
                            progressBar.dataset.status = progress.status;
                            if (progress.status === 'complete' || progress.status === 'error') {
                                document.querySelectorAll('.phase-card.active').forEach(card => stopPhaseTimer(card.dataset.label));
                                stopTotalTimer();
                            }
                            if (progress.status === 'complete') {
                                document.querySelectorAll('.phase-card').forEach(card => card.classList.add('done'));
                                document.getElementById('launch').disabled = false;
                                statusText.textContent = 'Complete';
                                updateTimers();
                            }
                            if (progress.status === 'error') {
                                document.getElementById('launch').disabled = false;
                                statusText.textContent = 'Failed';
                                updateTimers();
                            }
                        } catch (e) {
                            console.warn('Progress parse error', e);
                        }
            }
        };
    }

    document.getElementById('save-config').addEventListener('click', saveConfiguration);
            document.getElementById('launch').addEventListener('click', launchDeployment);
            document.getElementById('clear-terminal').addEventListener('click', () => terminalOutput.textContent = '');
            modeInputs.forEach(input => input.addEventListener('change', (e) => renderPhases(e.target.value)));

            renderPhases('automated');
            connectStream();
            updateTimers();
        </script>
</body>
</html>
